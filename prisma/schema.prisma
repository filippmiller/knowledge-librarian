// AI Knowledge Librarian - Database Schema
// PostgreSQL with pgvector for embeddings

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// CORE KNOWLEDGE OBJECTS
// ============================================

model Document {
  id          String      @id @default(cuid())
  title       String
  filename    String
  mimeType    String
  rawText     String?     @db.Text
  rawBytes    Bytes?
  uploadedAt  DateTime    @default(now())
  parseStatus ParseStatus @default(PENDING)
  parseError  String?
  retryCount  Int         @default(0)

  // Relations
  domains             DocumentDomain[]
  rules               Rule[]
  qaPairs             QAPair[]
  chunks              DocChunk[]
  domainSuggestions   DomainSuggestion[]
  stagedExtractions   StagedExtraction[]
  processingAttempts  ProcessingAttempt[]

  @@index([parseStatus])
}

enum ParseStatus {
  PENDING
  PROCESSING
  EXTRACTED // All processing phases complete, staged data ready for user review/commit
  COMPLETED
  FAILED
  DEAD      // Exceeded max retries — needs manual revival
}

// Dead Letter Queue — logs every processing attempt for a document
model ProcessingAttempt {
  id           String    @id @default(cuid())
  documentId   String
  document     Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  startedAt    DateTime  @default(now())
  completedAt  DateTime?
  status       String    // RUNNING | SUCCESS | FAILED
  errorMessage String?   @db.Text
  failedPhase  String?   // DOMAIN_CLASSIFICATION | KNOWLEDGE_EXTRACTION | CHUNKING
  durationMs   Int?

  @@index([documentId])
  @@index([status])
}

// Hierarchical domain structure
model Domain {
  id             String   @id @default(cuid())
  slug           String   @unique // dot-notation: "notary.veremiy_msk"
  title          String
  description    String?  @db.Text
  parentDomainId String?
  policy         Json? // domain-specific policies
  createdAt      DateTime @default(now())

  // Self-relation for hierarchy
  parentDomain Domain?  @relation("DomainHierarchy", fields: [parentDomainId], references: [id])
  childDomains Domain[] @relation("DomainHierarchy")

  // Relations
  documents        DocumentDomain[]
  rules            RuleDomain[]
  qaPairs          QADomain[]
  chunks           ChunkDomain[]
  librarianEntries LibrarianEntry[]
  notifications    UserNotification[]

  @@index([parentDomainId])
  @@index([slug])
}

// AI-suggested new domains awaiting approval
model DomainSuggestion {
  id                    String           @id @default(cuid())
  suggestedSlug         String
  title                 String
  description           String?          @db.Text
  parentSlug            String?
  confidence            Float
  reason                String           @db.Text
  status                SuggestionStatus @default(PENDING)
  createdFromDocumentId String?
  createdAt             DateTime         @default(now())
  reviewedAt            DateTime?
  reviewedBy            String?

  // Relations
  document Document? @relation(fields: [createdFromDocumentId], references: [id])

  @@index([status])
  @@index([createdFromDocumentId])
}

enum SuggestionStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============================================
// KNOWLEDGE UNITS (VERSIONED)
// ============================================

// Business rules extracted from documents
model Rule {
  id               String          @id @default(cuid())
  documentId       String?
  ruleCode         String // e.g., "R-1", "R-2"
  title            String
  body             String          @db.Text
  confidence       Float           @default(0.8)
  status           KnowledgeStatus @default(ACTIVE)
  version          Int             @default(1)
  supersedesRuleId String?
  sourceSpan       Json? // { quote, locationHint }
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // Relations
  document       Document?          @relation(fields: [documentId], references: [id])
  supersedesRule Rule?              @relation("RuleVersions", fields: [supersedesRuleId], references: [id])
  supersededBy   Rule[]             @relation("RuleVersions")
  domains        RuleDomain[]
  qaPairs        QAPair[]
  changes        KnowledgeChange[]  @relation("RuleChanges")
  favorites      UserFavorite[]
  comments       RuleComment[]
  notifications  UserNotification[]

  @@index([status])
  @@index([ruleCode])
  @@index([documentId])
}

// Q&A pairs extracted from documents
model QAPair {
  id             String          @id @default(cuid())
  documentId     String?
  ruleId         String?
  question       String          @db.Text
  answer         String          @db.Text
  status         KnowledgeStatus @default(ACTIVE)
  version        Int             @default(1)
  supersedesQaId String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  // Relations
  document     Document?         @relation(fields: [documentId], references: [id])
  rule         Rule?             @relation(fields: [ruleId], references: [id])
  supersedesQa QAPair?           @relation("QAVersions", fields: [supersedesQaId], references: [id])
  supersededBy QAPair[]          @relation("QAVersions")
  domains      QADomain[]
  changes      KnowledgeChange[] @relation("QAChanges")

  @@index([status])
  @@index([documentId])
  @@index([ruleId])
}

enum KnowledgeStatus {
  ACTIVE
  SUPERSEDED
  DEPRECATED
}

// ============================================
// RETRIEVAL UNITS (VECTOR SEARCH)
// ============================================

model DocChunk {
  id         String   @id @default(cuid())
  documentId String
  chunkIndex Int
  content    String   @db.Text
  embedding  Json? // vector embeddings stored as JSON array
  metadata   Json? // additional context
  createdAt  DateTime @default(now())

  // Relations
  document Document      @relation(fields: [documentId], references: [id], onDelete: Cascade)
  domains  ChunkDomain[]

  @@unique([documentId, chunkIndex])
  @@index([documentId])
}

// ============================================
// MAPPING TABLES (MANY-TO-MANY)
// ============================================

model DocumentDomain {
  documentId String
  domainId   String
  isPrimary  Boolean  @default(false)
  confidence Float    @default(0.8)
  assignedAt DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  domain   Domain   @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@id([documentId, domainId])
}

model RuleDomain {
  ruleId     String
  domainId   String
  confidence Float    @default(0.8)
  assignedAt DateTime @default(now())

  rule   Rule   @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  domain Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@id([ruleId, domainId])
}

model QADomain {
  qaId       String
  domainId   String
  confidence Float    @default(0.8)
  assignedAt DateTime @default(now())

  qa     QAPair @relation(fields: [qaId], references: [id], onDelete: Cascade)
  domain Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@id([qaId, domainId])
}

model ChunkDomain {
  chunkId    String
  domainId   String
  confidence Float    @default(0.8)
  assignedAt DateTime @default(now())

  chunk  DocChunk @relation(fields: [chunkId], references: [id], onDelete: Cascade)
  domain Domain   @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@id([chunkId, domainId])
}

// ============================================
// KNOWLEDGE LIFECYCLE & AUDIT
// ============================================

model KnowledgeChange {
  id          String           @id @default(cuid())
  targetType  ChangeTargetType
  targetId    String
  changeType  ChangeType
  oldValue    Json?
  newValue    Json?
  reason      String           @db.Text
  initiatedBy InitiatedBy
  approvedBy  String?
  status      ChangeStatus     @default(PENDING)
  createdAt   DateTime         @default(now())
  reviewedAt  DateTime?

  // Polymorphic relations
  rule   Rule?   @relation("RuleChanges", fields: [targetId], references: [id], map: "rule_change_fk")
  qaPair QAPair? @relation("QAChanges", fields: [targetId], references: [id], map: "qa_change_fk")

  @@index([targetType, targetId])
  @@index([status])
  @@index([createdAt])
}

enum ChangeTargetType {
  RULE
  QA_PAIR
}

enum ChangeType {
  CREATE
  UPDATE
  SUPERSEDE
  DEPRECATE
}

enum InitiatedBy {
  AI
  ADMIN
}

enum ChangeStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============================================
// AI QUESTIONS FOR HUMANS
// ============================================

model AIQuestion {
  id             String         @id @default(cuid())
  issueType      String // price_conflict, ambiguous_rule, outdated_info
  question       String         @db.Text
  context        Json? // related rule/doc info
  proposedChange Json? // { old, new }
  affectedRuleId String?
  status         QuestionStatus @default(OPEN)
  response       String?        @db.Text
  createdAt      DateTime       @default(now())
  respondedAt    DateTime?

  @@index([status])
  @@index([issueType])
}

enum QuestionStatus {
  OPEN
  ANSWERED
  DISMISSED
}

// ============================================
// SESSIONS & CHAT HISTORY
// ============================================

model ChatSession {
  id        String     @id @default(cuid())
  source    ChatSource @default(WEB)
  userId    String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  messages ChatMessage[]
}

model ChatMessage {
  id        String      @id @default(cuid())
  sessionId String
  role      MessageRole
  content   String      @db.Text
  metadata  Json? // domains used, chunks retrieved, confidence
  createdAt DateTime    @default(now())

  session ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}

enum ChatSource {
  WEB
  TELEGRAM
  API
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

// ============================================
// USER MANAGEMENT
// ============================================

model User {
  id           String    @id @default(cuid())
  username     String    @unique
  passwordHash String
  role         UserRole  @default(ADMIN)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  lastLoginAt  DateTime?

  @@index([username])
}

enum UserRole {
  ADMIN
  EDITOR
  VIEWER
}

// ============================================
// STAGED EXTRACTION (STREAMING PROCESSING)
// ============================================

model StagedExtraction {
  id         String          @id @default(cuid())
  documentId String
  phase      ExtractionPhase
  itemType   StagedItemType
  data       Json
  isVerified Boolean         @default(false)
  isRejected Boolean         @default(false)
  createdAt  DateTime        @default(now())
  verifiedAt DateTime?

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId, phase])
  @@index([documentId, isVerified])
}

enum ExtractionPhase {
  DOMAIN_CLASSIFICATION
  KNOWLEDGE_EXTRACTION
  CHUNKING
}

enum StagedItemType {
  DOMAIN_ASSIGNMENT
  DOMAIN_SUGGESTION
  RULE
  QA_PAIR
  UNCERTAINTY
  CHUNK
}

// ============================================
// TELEGRAM ACCESS CONTROL
// ============================================

enum TelegramUserRole {
  SUPER_ADMIN // Can manage all users, full knowledge management
  ADMIN // Can add/correct knowledge, upload docs, manage regular users
  USER // Can only ask questions
}

model TelegramUser {
  id         String           @id @default(cuid())
  telegramId String           @unique // Telegram user ID (numeric string)
  username   String? // @username, may change
  firstName  String?
  role       TelegramUserRole @default(USER)
  grantedBy  String? // telegramId of who granted access
  isActive   Boolean          @default(true)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  @@index([telegramId])
  @@index([role])
}

// ============================================
// AI SETTINGS
// ============================================

model AISettings {
  id             String    @id @default(cuid())
  provider       String    @default("openai")
  apiKey         String // Зашифрованный ключ
  model          String    @default("gpt-4o")
  embeddingModel String    @default("text-embedding-3-small")
  isActive       Boolean   @default(true)
  lastVerified   DateTime?
  lastError      String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}

// ============================================
// ANSWER FEEDBACK (FOR CONTINUOUS IMPROVEMENT)
// ============================================

model AnswerFeedback {
  id              String         @id @default(cuid())
  messageId       String? // Link to ChatMessage if available
  question        String         @db.Text
  answer          String         @db.Text
  rating          FeedbackRating
  feedbackType    FeedbackType?
  comment         String?        @db.Text
  suggestedAnswer String?        @db.Text // User's suggested correct answer
  confidence      Float? // Original answer confidence
  domainsUsed     Json? // Domains used for this answer
  createdAt       DateTime       @default(now())
  reviewedAt      DateTime?
  reviewedBy      String?
  resolution      String?        @db.Text

  @@index([rating])
  @@index([feedbackType])
  @@index([createdAt])
}

enum FeedbackRating {
  HELPFUL // Answer was helpful
  PARTIALLY // Answer was partially helpful
  NOT_HELPFUL // Answer was not helpful
  INCORRECT // Answer was incorrect/wrong
}

enum FeedbackType {
  MISSING_INFO // Answer lacked important information
  WRONG_INFO // Answer contained incorrect information
  OUTDATED_INFO // Information was outdated
  UNCLEAR // Answer was unclear or confusing
  OFF_TOPIC // Answer was about wrong topic
  GREAT // Answer was great (positive feedback)
}

// ============================================
// LIBRARIAN KNOWLEDGE MANAGEMENT SYSTEM
// ============================================

// Verification lifecycle for knowledge entries
enum VerificationStatus {
  UNVERIFIED // New entry, not yet reviewed
  VERIFIED // Reviewed and confirmed accurate
  CANONICAL // Authoritative source of truth
  DISPUTED // Conflicting information flagged
  STALE // Outdated, needs refresh
}

// Types of knowledge entries
enum LibrarianEntryType {
  FACT // Factual statement
  PROCEDURE // Process or workflow
  RULE // Business rule
  DEFINITION // Term definition
  REFERENCE // External reference
}

// Source of knowledge entries
enum LibrarianSourceType {
  MANUAL // Human-entered
  AI_EXTRACTED // Extracted by AI from documents
  RULE_IMPORT // Imported from Rule model
  QA_IMPORT // Imported from QAPair model
  AGENT // Created by an AI agent
}

// Agent activity types for compliance tracking
enum AgentActivityType {
  SEARCH // Knowledge search
  INGEST // Knowledge creation
  UPDATE // Knowledge update
  VERIFY // Verification action
  DISPUTE // Dispute flagging
}

// Librarian change types for audit log
enum LibrarianChangeType {
  CREATE
  UPDATE
  VERIFY
  DISPUTE
  REVALIDATE
  ARCHIVE
}

// Core knowledge entries with verification lifecycle
model LibrarianEntry {
  id                 String              @id @default(cuid())
  title              String
  content            String              @db.Text
  contentHash        String              @unique // SHA-256 for deduplication
  domainId           String?
  entryType          LibrarianEntryType  @default(FACT)
  verificationStatus VerificationStatus  @default(UNVERIFIED)
  freshnessScore     Float               @default(1.0) // 0.0 - 1.0, decays over time
  lastValidatedAt    DateTime            @default(now())
  expiresAt          DateTime?
  evidence           Json? // { commit_hash, files_changed, functions_affected, test_results }
  sourceType         LibrarianSourceType @default(MANUAL)
  sourceId           String? // Reference to Rule.id, QAPair.id, etc.
  embedding          Json? // vector embeddings as JSON array
  keywords           String[] // Extracted keywords for filtering
  entities           Json? // { files: [], functions: [], tables: [], endpoints: [] }
  createdBy          String? // Agent ID or user ID
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  // Relations
  domain  Domain?           @relation(fields: [domainId], references: [id])
  changes LibrarianChange[]

  @@index([verificationStatus])
  @@index([freshnessScore])
  @@index([domainId])
  @@index([entryType])
  @@index([createdAt])
}

// Agent compliance and activity tracking
model LibrarianAgentActivity {
  id            String            @id @default(cuid())
  agentId       String
  activityType  AgentActivityType
  entryId       String?
  details       Json? // { query, results, duration_ms, etc. }
  rulesFollowed String[] // List of rule IDs followed
  rulesViolated String[] // List of rule IDs violated
  createdAt     DateTime          @default(now())

  @@index([agentId])
  @@index([activityType])
  @@index([createdAt])
}

// Search analytics for optimization
model LibrarianSearchMetrics {
  id              String   @id @default(cuid())
  query           String   @db.Text
  queryHash       String // For aggregation
  resultCount     Int
  avgRelevance    Float
  topResultId     String?
  searchTimeMs    Int
  embeddingTimeMs Int?
  clickedResultId String?
  wasHelpful      Boolean?
  createdAt       DateTime @default(now())

  @@index([queryHash])
  @@index([createdAt])
}

// Audit log for Librarian changes
model LibrarianChange {
  id         String              @id @default(cuid())
  entryId    String
  changeType LibrarianChangeType
  oldValue   Json?
  newValue   Json?
  reason     String              @db.Text
  changedBy  String // Agent ID or user ID
  createdAt  DateTime            @default(now())

  entry LibrarianEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)

  @@index([entryId])
  @@index([changeType])
  @@index([createdAt])
}

// ============================================
// MINI APP FEATURES (Favorites, Comments, Notifications)
// ============================================

// User favorites (bookmarked rules)
model UserFavorite {
  id         String   @id @default(cuid())
  telegramId String
  ruleId     String
  createdAt  DateTime @default(now())
  notes      String?  @db.Text // User's personal notes about this rule

  rule Rule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@unique([telegramId, ruleId])
  @@index([telegramId])
  @@index([ruleId])
}

// Comments on rules (discussion)
model RuleComment {
  id         String   @id @default(cuid())
  ruleId     String
  telegramId String
  content    String   @db.Text
  parentId   String? // For threaded replies
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  isEdited   Boolean  @default(false)
  isDeleted  Boolean  @default(false)

  rule    Rule          @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  parent  RuleComment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies RuleComment[] @relation("CommentReplies")

  @@index([ruleId])
  @@index([telegramId])
  @@index([parentId])
  @@index([createdAt])
}

// User notification preferences and subscriptions
model UserNotification {
  id             String           @id @default(cuid())
  telegramId     String
  type           NotificationType
  domainId       String? // Subscribe to specific domain
  ruleId         String? // Subscribe to specific rule updates
  keywords       Json? // Array of keywords to watch
  isActive       Boolean          @default(true)
  lastNotifiedAt DateTime?
  createdAt      DateTime         @default(now())

  domain Domain? @relation(fields: [domainId], references: [id], onDelete: Cascade)
  rule   Rule?   @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([telegramId])
  @@index([domainId])
  @@index([ruleId])
}

enum NotificationType {
  NEW_RULE
  RULE_UPDATED
  NEW_DOCUMENT
  KEYWORD_MATCH
}

// User preferences for Mini App
model UserPreference {
  id           String   @id @default(cuid())
  telegramId   String   @unique
  theme        String   @default("system") // light, dark, system
  fontSize     String   @default("medium") // small, medium, large
  offlineCache Boolean  @default(true)
  pushEnabled  Boolean  @default(true)
  language     String   @default("ru")
  lastSyncedAt DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([telegramId])
}

// Notification log (sent notifications)
model NotificationLog {
  id         String           @id @default(cuid())
  telegramId String
  type       NotificationType
  title      String
  message    String           @db.Text
  ruleId     String?
  documentId String?
  isRead     Boolean          @default(false)
  sentAt     DateTime         @default(now())
  readAt     DateTime?

  @@index([telegramId])
  @@index([isRead])
  @@index([sentAt])
}
